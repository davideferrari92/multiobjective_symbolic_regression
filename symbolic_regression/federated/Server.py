import logging
from multiprocessing.connection import Listener
from typing import Dict

from symbolic_regression.federated.Agent import FederatedAgent
from symbolic_regression.federated.Communication import \
    FederatedDataCommunication
from symbolic_regression.federated.strategies.BaseStrategy import BaseStrategy


class FederatedSRServer(FederatedAgent):

    def __init__(self, name: str, address: str, port: int, orchestrator_address: str, orchestrator_port: int) -> None:
        """ This class implement a Federated Symbolic Regression Server

        An aggregator server is an agent that implements the aggregation side of the
        Federated Learning algorithm. It receives the model updates from the clients,
        via the orchestrator, and aggregates them to produce a new model.
        The rule for the aggregation is defined by the strategy used by the server and 
        received from the orchestrator at the moment of the registration.
        The server is developed to support the following communications from the orchestrator:

            - RegisterServer
                return the confirmation by the orchestrator of sucessful registration
            - UnregisterServer
                return the confirmation by the orchestrator of sucessful unregistration
            - SendAggregationStrategy
                this message is sent by the orchestrator to server and clients to pass the aggregation strategy to be used
            - SendTrainingConfiguration
                this message is sent by the orchestrator to server and clients to pass the training configuration to be used
            - SyncRegisteredAgents
                this message is sent by the orchestrator to server and clients to sync the list of registered agents every time
                a new agent is registered or unregistered
            - Terminate
                this message is sent by the orchestrator to server and clients to trigger the termination of the server
            - ToServerAggregationStrategies
                this message is sent by the orchestrator to the server to pass the list of aggregation strategies
                generated by the clients and that are available to aggregate.
            - TriggerAggregation
                this message is sent by the orchestrator to server and clients to trigger the aggregation of the models
                It has effect only on the server. Clients use TriggerTraining
            - TriggerTraining
                this message is sent by the orchestrator to server and clients to trigger the training of the models.
                In case of the server, it has no effect.

        Args:
            - name: str
                Name of the server
            - address: str
                Address of the server
            - port: int
                Port of the server
            - orchestrator_address: str
                Address of the orchestrator
            - orchestrator_port: int
                Port of the orchestrator

        Returns:
            - None
        """
        super().__init__(name=name, address=address, port=port,
                         orchestrator_address=orchestrator_address, orchestrator_port=orchestrator_port)

        self.mode: str = 'server'
        self.status: str = 'idle'

        self.federated_aggregation_strategies: Dict[str, BaseStrategy] = None

    def register(self) -> bool:
        """ Register the client to the orchestrator and start the client

        Returns:
            - None
        """
        self.send_to_orchestrator(
            comm_type='RegisterServer', payload=self.name)

        try:
            self.run_server()
        except KeyboardInterrupt:
            logging.info(f'Server stopped by user')
            self.send_to_orchestrator(
                comm_type='UnregisterServer', payload=self.name)

    def run_server(self):
        if not self.orchestrator_address or not self.orchestrator_port:
            raise AttributeError(
                'Orchestrator address and port not set for this server')

        listener = Listener((self.address, self.port))

        logging.info(
            f'Server {self.name} listening on {self.address}:{self.port}...')

        while True:
            """ Wait for a message from a client or a server

            For a better execution flow, we recommend to invoke any sender method
            as last instruction of each branch of the if statement.
            This will allow the listener to immediately be ready to receive
            the next message.
            """
            conn = listener.accept()
            msg: FederatedDataCommunication = conn.recv()

            if msg.comm_type == 'RegisterServer':
                """
                From 1 Orchestrator
                To None
                """
                if msg.payload is True:
                    self.is_registered = True
                    self.status = 'idle'
                    logging.info(f'Server {self.name} registered')
                else:
                    self.is_registered = False
                    logging.warning(f'Server {self.name} already registered')

                self.send_to_orchestrator(
                    comm_type='SyncStatus', payload=self.status)

            elif msg.comm_type == 'SendAggregationStrategy':
                """
                From 1 Orchestrator
                To None

                """
                self.federated_aggregation_strategy = msg.payload
                logging.debug(
                    f'Aggregation strategy received.')

            elif msg.comm_type == 'SendTrainingConfiguration':
                """
                From 1 Orchestrator
                To None
                """
                self.training_configuration = msg.payload
                logging.debug(
                    f'Training configuration received.')

            elif msg.comm_type == 'SyncRegisteredAgents':
                """
                From 1 Orchestrator
                To None
                """
                self.clients = msg.payload['clients']
                self.servers = msg.payload['servers']

            elif msg.comm_type == 'Terminate':
                """
                From 1 Orchestrator
                To None
                """
                self.status = 'terminated'

                return

            elif msg.comm_type == 'ToServerAggregationStrategies':
                """
                From 1 Orchestrator
                To None
                """
                self.federated_aggregation_strategies: Dict[str,
                                                            BaseStrategy] = msg.payload

            elif msg.comm_type == 'TriggerAggregation':
                """
                From 1 Orchestrator
                To None
                """
                self.status = 'aggregating'
                self.sync_status()

                self.federated_aggregation_strategy.execute(regressors={
                                                            name: aggregator.regressor for name, aggregator in self.federated_aggregation_strategies.items()})

                self.send_to_orchestrator(
                    comm_type='ToOrchestratorAggregationStrategy', payload=self.federated_aggregation_strategy)

                self.status = 'idle'

            elif msg.comm_type == 'TriggerTraining':
                """
                From 1 Orchestrator
                To None
                """
                logging.info(f'Clients training triggered')

            else:
                logging.warning(f'Unknown message type: {msg.comm_type}')
